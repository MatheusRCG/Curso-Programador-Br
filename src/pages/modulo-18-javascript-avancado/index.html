<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Javascript Avançado</title>
  <link rel="icon" href="../../images/icon.png" type="image/png">
  <link rel="stylesheet" href="../../css/main.css">
</head>

<body>
  <header id="top-bar">
    <a href="/">
      <img class="logo" src="../../images/logo.png" alt="logo">
    </a>
    <h1>Javascript Avançado</h1>
  </header>

  <nav id="nav">
    <ul>

    </ul>
  </nav>

  <main id="content">
    <article id="strict-mode-article" class="card">
      <h2>Strict Mode</h2>
      <p>
        O <code>strict mode</code> é uma funcionalidade do JavaScript que permite que você coloque seu
        código em um modo estrito. Isso ajuda a identificar erros silenciosos, melhorar a
        otimização e evitar o uso de algumas funcionalidades que são consideradas más práticas.
      </p>
      <p>
        Para ativar o <code>strict mode</code> em um arquivo JavaScript, basta adicionar a linha
        <code>"use strict";</code> no início do arquivo ou no início de uma função.
      </p>
      <pre>
        <code>
          "use strict";
          // Código JavaScript aqui
        </code>
      </pre>
      <p>
        Quando o <code>strict mode</code> está ativado, algumas mudanças ocorrem no comportamento
        do JavaScript:
      </p>
      <ul>
        <li>Variáveis devem ser declaradas antes de serem usadas.</li>
        <li>Não é permitido deletar variáveis, funções ou argumentos.</li>
        <li>Não é permitido duplicar nomes de parâmetros em funções.</li>
        <li>Não é permitido usar palavras reservadas como nomes de variáveis.</li>
      </ul>
      <p>
        O <code>strict mode</code> é uma boa prática para garantir que seu código JavaScript seja
        mais seguro e menos propenso a erros.
      </p>
    </article>
    <article id="this-bind-article" class="card">
      <h2>This e Bind</h2>
      <p>
        O <code>this</code> é uma palavra-chave especial em JavaScript que se refere ao objeto atual.
        O valor de <code>this</code> depende de como uma função é chamada.
      </p>
      <p>
        Quando uma função é chamada como um método de um objeto, o valor de <code>this</code> é o
        objeto em que a função é chamada.
      </p>
      <pre>
        <code>
          const person = {
            firstName: "John",
            lastName: "Doe",
            fullName: function() {
              return this.firstName + " " + this.lastName;
            }
          };
          console.log(person.fullName()); // John Doe
        </code>
      </pre>
      <p>
        No entanto, quando uma função é chamada como uma função normal, o valor de
        <code>this</code> é o objeto global (no navegador, o objeto global é "window").
      </p>
      <pre>
        <code>
          function myFunction() {
            return this;
          }
          console.log(myFunction()); // window
        </code>
      </pre>
      <p>
        Para resolver esse problema, você pode usar o método <code>bind</code> para definir o
        valor de <code>this</code> para uma função.
      </p>
      <pre>
        <code>
          const person = {
            firstName: "John",
            lastName: "Doe"
          };
          function fullName() {
            return this.firstName + " " + this.lastName;
          }
          const fullNameBound = fullName.bind(person);
          console.log(fullNameBound()); // John Doe
        </code>
      </pre>
      <p>
        O método <code>bind</code> cria uma nova função que, quando chamada, tem o valor de
        <code>this</code> definido para o primeiro argumento passado para o método <code>bind</code>.
      </p>
    </article>
    <article id="arrow-functions-article" class="card">
      <h2>Arrow Functions</h2>
      <p>
        As <code>arrow functions</code> são uma nova sintaxe introduzida no ECMAScript 6 para
        criar funções de forma mais concisa.
      </p>
      <p>
        A sintaxe de uma <code>arrow functions</code> é a seguinte:
      </p>
      <pre>
        <code>
          const add = (a, b) =&gt; {
            return a + b;
          };
          console.log(add(1, 2)); // 3
        </code>
      </pre>
      <p>
        Se a função tiver apenas uma instrução, você pode omitir as chaves e a
        palavra-chave <code>return</code>.
      </p>
      <pre>
        <code>
          const add = (a, b) =&gt; a + b;
          console.log(add(1, 2)); // 3
        </code>
      </pre>
      <p>
        As <code>arrow functions</code> têm algumas diferenças em relação às
        funções tradicionais:
      </p>
      <ul>
        <li>O valor de <code>this</code> é herdado do escopo pai.</li>
        <li>Não têm a palavra-chave "arguments".</li>
        <li>Não podem ser usadas como construtores.</li>
      </ul>
      <p>
        As <code>arrow functions</code> são úteis para escrever código mais conciso e
        legível em JavaScript.
      </p>
    </article>
    <article id="callback-article" class="card">
      <h2>Callback</h2>
      <p>
        Um <code>callback</code> é uma função que é passada como argumento para outra função
        e é executada após a conclusão
        de uma operação assíncrona.
      </p>
      <p>
        Os <code>callbacks</code> são amplamente utilizados em JavaScript para lidar
        com operações assíncronas, como requisições AJAX, eventos de temporização
        e manipulação de arquivos.
      </p>
      <pre>
        <code>
          function fetchData(callback) {
            setTimeout(() =&gt; {
              const data = "Hello, world!";
              callback(data);
            }, 1000);
          }
          function displayData(data) {
            console.log(data);
          }
          fetchData(displayData); // Hello, world!
        </code>
      </pre>
      <p>
        Neste exemplo, a função <code>fetchData</code> recebe um <code>callback</code> como argumento e
        chama o <code>callback</code> após um atraso de 1 segundo.
      </p>
      <p>
        Os <code>callback</code> são uma parte fundamental da programação assíncrona em JavaScript
        e são uma maneira eficaz de lidar com operações que não são imediatamente concluídas.
      </p>
    </article>
    <article id="promises-article" class="card">
      <h2>Promises</h2>
      <p>
        As <code>promises</code> são um recurso do JavaScript introduzido no ECMAScript 6 para
        lidar com operações assíncronas de forma mais limpa e legível.
      </p>
      <p>
        Uma <code>promise</code> representa um valor que pode estar disponível agora, no futuro
        ou nunca.
      </p>
      <pre>
        <code>
          const fetchData = new Promise((resolve, reject) =&gt; {
            setTimeout(() =&gt; {
              const data = "Hello, world!";
              resolve(data);
            }, 1000);
          });
          fetchData.then(data =&gt; {
            console.log(data);
          }); // Hello, world!
        </code>
      </pre>
      <p>
        Neste exemplo, a <code>promise</code> <code>fetchData</code> é criada com uma função executora
        que chama a função <code>resolve</code> após um atraso de 1 segundo.
      </p>
      <p>
        As <code>promises</code> são uma maneira poderosa de lidar com operações assíncronas em
        JavaScript e são amplamente utilizadas em bibliotecas e frameworks modernos.
      </p>
    </article>
    <article id="async-await-article" class="card">
      <h2>Async e Await</h2>
      <p>
        O <code>async</code> e <code>await</code> são recursos do JavaScript introduzidos no ECMAScript 8
        para simplificar o uso de <code>promises</code>.
      </p>
      <p>
        A palavra-chave <code>async</code> é usada para declarar uma função assíncrona que retorna
        uma <code>promise</code>.
      </p>
      <pre>
        <code>
          async function fetchData() {
            return new Promise((resolve, reject) =&gt; {
              setTimeout(() =&gt; {
                const data = "Hello, world!";
                resolve(data);
              }, 1000);
            });
          }
          async function displayData() {
            const data = await fetchData();
            console.log(data);
          }
          displayData(); // Hello, world!
        </code>
      </pre>
      <p>
        Neste exemplo, a função <code>fetchData</code> é declarada como uma função assíncrona
        e a palavra-chave <code>await</code> é usada para esperar que a <code>promise</code> seja resolvida.
      </p>
      <p>
        O <code>async</code> e <code>await</code> são uma maneira mais limpa e legível de lidar com
        operações assíncronas em JavaScript e são amplamente utilizados em código moderno.
      </p>
    </article>
    <article id="filter-article" class="card">
      <h2>Filter</h2>
      <p>
        O método <code>filter</code> é um método de array em JavaScript que cria um novo array
        com todos os elementos que passam em um teste implementado por uma função fornecida.
      </p>
      <pre>
        <code>
          const numbers = [1, 2, 3, 4, 5];
          const evenNumbers = numbers.filter(number =&gt; number % 2 === 0);
          console.log(evenNumbers); // [2, 4]
        </code>
      </pre>
      <p>
        Neste exemplo, o método <code>filter</code> é usado para criar um novo array com
        os números pares do array original.
      </p>
      <p>
        O método <code>filter</code> é uma maneira eficaz de filtrar elementos de um array
        com base em uma condição específica.
      </p>
    </article>
    <article id="map-reduce-article" class="card">
      <h2>Map e Reduce</h2>
      <p>
        O método <code>map</code> é um método de array em JavaScript
        que permitem transformar arrays de forma eficiente.
      </p>
      <p>
        O método <code>map</code> cria um novo array com os resultados de chamar uma função
        para cada elemento do array.
      </p>
      <pre>
        <code>
          const numbers = [1, 2, 3, 4, 5];
          const squaredNumbers = numbers.map(number =&gt; number * number);
          console.log(squaredNumbers); // [1, 4, 9, 16, 25]
        </code>
      </pre>
      <p>
        Neste exemplo, o método <code>map</code> é usado para criar um novo array com
        os números ao quadrado do array original.
      </p>
    </article>
    <article id="value-reference-article" class="card">
      <h2>Valor vs Referência</h2>
      <p>
        Em JavaScript, os tipos de dados primitivos (como números, strings e booleanos) são
        passados por valor, enquanto os objetos (como arrays e objetos) são passados por referência.
      </p>
      <p>
        Quando um tipo de dado primitivo é passado para uma função, uma cópia do valor é passada,
        o que significa que a função não pode modificar o valor original.
      </p>
      <pre>
        <code>
          let x = 10;
          function increment(x) {
            x++;
          }
          increment(x);
          console.log(x); // 10
        </code>
      </pre>
      <p>
        No entanto, quando um objeto é passado para uma função, uma referência ao objeto é passada,
        o que significa que a função pode modificar o objeto original.
      </p>
      <pre>
        <code>
          let person = { name: "John" };
          function changeName(person) {
            person.name = "Jane";
          }
          changeName(person);
          console.log(person.name); // Jane
        </code>
      </pre>
    </article>
    <article id="spread-operator-article" class="card">
      <h2>Spread Operator</h2>
      <p>
        O <code>spread operator</code> é uma nova sintaxe introduzida no ECMAScript 6 para
        espalhar elementos de um array ou objeto.
      </p>
      <p>
        O <code>spread operator</code> é representado por três pontos (<code>...</code>) e pode ser
        usado para copiar elementos de um array ou objeto para outro array ou objeto.
      </p>
      <pre>
        <code>
          const numbers = [1, 2, 3];
          const newNumbers = [...numbers, 4, 5];
          console.log(newNumbers); // [1, 2, 3, 4, 5]
        </code>
      </pre>
      <p>
        O <code>spread operator</code> é uma maneira eficaz de combinar arrays e objetos em JavaScript
        de forma concisa e legível.
      </p>
    </article>
    <article id="Reduce-article" class="card">
      <h2>Reduce</h2>
      <p>
        O método <code>reduce</code> é um método de array em JavaScript que reduz um array a um único valor.
      </p>
      <p>
        O método <code>reduce</code> executa uma função fornecida para cada elemento do array
        (da esquerda para a direita) e acumula o resultado em um valor único.
      </p>
      <pre>
        <code>
          const numbers = [1, 2, 3, 4, 5];
          
          function soma(acumulador, numero) {
            return acumulador + numero;
          }

          console.log(numbers.reduce(soma, 0)); // 15
        </code>
      </pre>
      <p>
        Neste exemplo, o método <code>reduce</code> é usado para somar todos os números do array.
      </p>
      <p>
        O método <code>reduce</code> é uma maneira poderosa de transformar arrays em um único valor
        e é amplamente utilizado em operações de agregação de dados.
      </p>      
    </article>
  </main>

  <footer id="footer">
    <a href="https://github.com/MatheusRCG" target="_blank">
      <img src="/src/images/github-logo.png" alt="logo github">
    </a>
    <a href="https://www.linkedin.com/in/matheusrcg/" target="_blank">
      <img src="/src/images/linkedin-logo.png" alt="linkedin logo">
    </a>
  </footer>

  <script src="./modulo-18.js"></script>
</body>

</html>